// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGCreatureSpawner.h"

#if WITH_EDITOR
void AFGCreatureSpawner::PostEditMove(bool bFinished){ }
void AFGCreatureSpawner::PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent){ Super::PostEditChangeProperty(PropertyChangedEvent); }
#endif 
#if !UE_BUILD_SHIPPING
void AFGCreatureSpawner::DrawDebugInformation(float duration){ }
#endif 
AFGCreatureSpawner::AFGCreatureSpawner(){ }
void AFGCreatureSpawner::BeginPlay(){ }
void AFGCreatureSpawner::EndPlay(const EEndPlayReason::Type endPlayReason){ }
void AFGCreatureSpawner::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PostSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PreLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCreatureSpawner::GatherDependencies_Implementation(TArray< UObject* >& out_dependentObjects){ }
bool AFGCreatureSpawner::NeedTransform_Implementation(){ return bool(); }
bool AFGCreatureSpawner::ShouldSave_Implementation() const{ return bool(); }
void AFGCreatureSpawner::GetSpawnLocations(TArray<FVector>& out_spawnLocations) const{ }
TSubclassOf< class AFGCreature > AFGCreatureSpawner::GetCreatureToSpawn_Implementation() const{ return TSubclassOf<class AFGCreature>(); }
bool AFGCreatureSpawner::CanSpawnCreature(const FSpawnData& spawnData) const{ return bool(); }
int32 AFGCreatureSpawner::GetNumUnspawnedCreatures() const{ return int32(); }
bool AFGCreatureSpawner::IsReadyToSpawn(){ return bool(); }
void AFGCreatureSpawner::SpawnCreatures(){ }
void AFGCreatureSpawner::SpawnSingleCreature(){ }
void AFGCreatureSpawner::DestroyCreatures(){ }
bool AFGCreatureSpawner::ShouldResetKillStatus(const FSpawnData& spawnData, int32 newDayNr){ return bool(); }
void AFGCreatureSpawner::UpdateKillStatus(int32 newDayNr){ }
bool AFGCreatureSpawner::IsTimeForCreature() const{ return bool(); }
void AFGCreatureSpawner::CreatureDied(AActor* thisActor){ }
bool AFGCreatureSpawner::CalculateSpawningLocations(){ return bool(); }
float AFGCreatureSpawner::GetSpawnDistance() const{ return float(); }
void AFGCreatureSpawner::UpdateScannableState(){ }
void AFGCreatureSpawner::TryRecoupleCreatureAndSpawner(){ }
void AFGCreatureSpawner::OnSpawningFinished(){ }
bool AFGCreatureSpawner::TryFindNonOverlappingLocation(const TArray<FVector2D>& usedSpawnLocations, float spawnRadius, int32 maxRetries, FVector2D& out_location){ return bool(); }
bool AFGCreatureSpawner::IsLocationNonOverlapping(const FVector2D& location, const TArray< FVector2D >& usedLocations) const{ return bool(); }
void AFGCreatureSpawner::RegisterAsNavigationInvoker(bool shouldRegister){ }
void AFGCreatureSpawner::ReceiveOnTraceCompleted(const TArray< FOverlapResult > & Results){ }
void AFGCreatureSpawner::TraceForNearbyBase(){ }
void AFGCreatureSpawner::OnTraceCompleted(const FTraceHandle& Handle, FOverlapDatum& Data){ }
