// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGWheeledVehicle.h"

TAutoConsoleVariable<int32> CVarVehicleDebug(TEXT("CVarVehicleDebug"), 0, TEXT(""));
void AFGWheeledVehicle::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const{ }
AFGWheeledVehicle::AFGWheeledVehicle(){ }
void AFGWheeledVehicle::PostInitializeComponents(){ Super::PostInitializeComponents(); }
void AFGWheeledVehicle::BeginPlay(){ }
void AFGWheeledVehicle::EndPlay(const EEndPlayReason::Type EndPlayReason){ }
void AFGWheeledVehicle::Destroyed(){ }
void AFGWheeledVehicle::Tick(float dt){ }
void AFGWheeledVehicle::DisplayDebug(UCanvas* canvas, const FDebugDisplayInfo& debugDisplay, float& YL, float& YPos){ }
bool AFGWheeledVehicle::DriverEnter(AFGCharacterPlayer* driver){ return bool(); }
bool AFGWheeledVehicle::DriverLeave(bool keepDriving){ return bool(); }
void AFGWheeledVehicle::Server_DriverLeave_Implementation(){ }
bool AFGWheeledVehicle::CanLeaveVehicle(AFGCharacterPlayer* character){ return bool(); }
void AFGWheeledVehicle::GainedSignificance_Implementation(){ }
void AFGWheeledVehicle::LostSignificance_Implementation(){ }
bool AFGWheeledVehicle::CanDock_Implementation(EDockStationType atStation) const{ return bool(); }
UFGInventoryComponent* AFGWheeledVehicle::GetDockInventory_Implementation() const{ return nullptr; }
UFGInventoryComponent* AFGWheeledVehicle::GetDockFuelInventory_Implementation() const{ return nullptr; }
void AFGWheeledVehicle::WasDocked_Implementation(AFGBuildableDockingStation* atStation){ }
void AFGWheeledVehicle::WasUndocked_Implementation(){ }
void AFGWheeledVehicle::OnBeginLoadVehicle_Implementation(){ }
void AFGWheeledVehicle::OnBeginUnloadVehicle_Implementation(){ }
void AFGWheeledVehicle::OnTransferComplete_Implementation(){ }
void AFGWheeledVehicle::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGWheeledVehicle::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGWheeledVehicle::StartIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGWheeledVehicle::StopIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGWheeledVehicle::OnVehicleLanded(){ }
void AFGWheeledVehicle::AddInputBindings(UInputComponent* enhancedInput){ }
void AFGWheeledVehicle::Multicast_OnVehicleEntered_Implementation(){ }
void AFGWheeledVehicle::Input_ThrottleSteer(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_LookAxis(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_Handbrake(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_Honk(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_ToggleCamera(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_ToggleLights(const FInputActionValue& actionValue){ }
void AFGWheeledVehicle::Input_OpenRecorder(const FInputActionValue& actionValue){ }
FVector AFGWheeledVehicle::GetVehicleRealActorLocation() const{ return FVector(); }
UStaticMeshComponent* AFGWheeledVehicle::FindAttachedStaticMesh_Implementation(){ return nullptr; }
UFGWheeledVehicleMovementComponent* AFGWheeledVehicle::GetVehicleMovementComponent() const{ return nullptr; }
bool AFGWheeledVehicle::HasFuel() const{ return bool(); }
float AFGWheeledVehicle::GetForwardSpeed() const{ return float(); }
bool AFGWheeledVehicle::IsValidFuel(TSubclassOf< UFGItemDescriptor > resource) const{ return bool(); }
bool AFGWheeledVehicle::FilterFuelClasses(TSubclassOf< UObject > object, int32 idx) const{ return bool(); }
bool AFGWheeledVehicle::ConsumesFuel(){ return bool(); }
float AFGWheeledVehicle::GetFuelBurnRatio(){ return float(); }
AFGDrivingTargetList* AFGWheeledVehicle::GetTargetList(bool createIfNeeded){ return nullptr; }
bool AFGWheeledVehicle::GetPathVisibility() const{ return bool(); }
void AFGWheeledVehicle::MeasureVelocities(float deltaTime){ }
FText AFGWheeledVehicle::GetDefaultMapName(TSubclassOf< AFGWheeledVehicle > vehicleType){ return FText(); }
void AFGWheeledVehicle::SyncWithSimulation(){ }
bool AFGWheeledVehicle::HasFullTank() const{ return bool(); }
float AFGWheeledVehicle::GetTotalFuelEnergy() const{ return float(); }
float AFGWheeledVehicle::CalculateFuelNeed() const{ return float(); }
float AFGWheeledVehicle::GetMaxFuelEnergy(TSubclassOf< UFGItemDescriptor > fuelClass){ return float(); }
float AFGWheeledVehicle::GetMaxFuelEnergy() const{ return float(); }
bool AFGWheeledVehicle::HasFuelForRoundtrip() const{ return bool(); }
bool AFGWheeledVehicle::IsSufficientFuelType(TSubclassOf< UFGItemDescriptor > fuelType) const{ return bool(); }
ETransferAnimationState AFGWheeledVehicle::GetTransferAnimationState(float animationLength, float& animationTime) const{ return ETransferAnimationState(); }
void AFGWheeledVehicle::CalculateManualDockingState(){ }
void AFGWheeledVehicle::SetRefuelingStation(AFGBuildableDockingStation* station){ }
void AFGWheeledVehicle::DockToRefuelingStation(){ }
void AFGWheeledVehicle::UpdatePlayerStatus(){ }
void AFGWheeledVehicle::Died(AActor* thisActor){ }
void AFGWheeledVehicle::SetSimulated(bool newIsSimulated){ }
void AFGWheeledVehicle::CreateInventoryItemDrops_Implementation(){ }
void AFGWheeledVehicle::SmoothMovementReplication(float DeltaTime){ }
void AFGWheeledVehicle::ReplicateMovementClientToServer_Implementation(FVector AuthoritativeLoc, FQuat AuthoritativeQuat, FVector AuthoritativeVelocity){ }
void AFGWheeledVehicle::OnCustomizationDataApplied(const FFactoryCustomizationData& customizationData){ }
void AFGWheeledVehicle::TickPendingVehicleCollisions(float dt){ }
void AFGWheeledVehicle::EnsureInfoCreated(){ }
void AFGWheeledVehicle::BurnFuel(float dt){ }
void AFGWheeledVehicle::SetRecordingStatus(ERecordingStatus recordingStatus){ }
void AFGWheeledVehicle::OnFuelAdded(TSubclassOf< UFGItemDescriptor > itemClass, int32 numAdded){ }
void AFGWheeledVehicle::OnRep_TransferStatusChanged(){ }
void AFGWheeledVehicle::StopVehicle(){ }
float AFGWheeledVehicle::AdjustThrottle(float throttle) const{ return float(); }
void AFGWheeledVehicle::StartRecording(){ }
void AFGWheeledVehicle::StopRecording(bool isValid){ }
void AFGWheeledVehicle::TickRecording(float deltaTime){ }
void AFGWheeledVehicle::PlaceTargetPoint(){ }
void AFGWheeledVehicle::ClearTargetList(){ }
void AFGWheeledVehicle::CacheSpeedInKMH(){ }
bool AFGWheeledVehicle::ShouldStopVehicle() const{ return bool(); }
void AFGWheeledVehicle::StopAllMovement(){ }
float AFGWheeledVehicle::GetLocalTime() const{ return float(); }
void AFGWheeledVehicle::MoveForward(float throttle, float brake){ }
void AFGWheeledVehicle::MoveRight(float axisValue){ }
void AFGWheeledVehicle::Server_SetVehicleLightsOn_Implementation(bool active){ }
void AFGWheeledVehicle::OnVehicleLightStatusChanged_Implementation(){ }
void AFGWheeledVehicle::Server_SetHonkStatus_Implementation(bool active){ }
void AFGWheeledVehicle::OnHonkStatusChanged_Implementation(){ }
void AFGWheeledVehicle::OnOpenRecorderMenu_Implementation(){ }
void AFGWheeledVehicle::TurnOverVehicle(){ }
bool AFGWheeledVehicle::IsFollowingPath() const{ return bool(); }
void AFGWheeledVehicle::SetIsPossessed(bool isPossessed){ }
bool AFGWheeledVehicle::CanLoadPath() const{ return bool(); }
bool AFGWheeledVehicle::CanSavePath() const{ return bool(); }
void AFGWheeledVehicle::PickNextTarget(){ }
void AFGWheeledVehicle::Server_ToggleAutoPilot_Implementation(){ }
void AFGWheeledVehicle::Server_TogglePathVisibility_Implementation(){ }
void AFGWheeledVehicle::Server_ToggleRecording_Implementation(){ }
void AFGWheeledVehicle::Server_ClearRecordedPath_Implementation(){ }
void AFGWheeledVehicle::Server_SavePath_Implementation(const FString& saveName){ }
void AFGWheeledVehicle::Server_UnsavePath_Implementation(AFGSavedWheeledVehiclePath* path){ }
void AFGWheeledVehicle::Server_LoadPath_Implementation( AFGDrivingTargetList* targetList){ }
void AFGWheeledVehicle::FindSavedPaths(const FString& textFilter, bool filterOnVehicleType, TArray< AFGSavedWheeledVehiclePath* >& result) const{ }
void AFGWheeledVehicle::OnRep_RecordingStatus(){ }
void AFGWheeledVehicle::OnRep_ManualDockingState(){ }
void AFGWheeledVehicle::OnRep_IsAutopilotEnabled(){ }
void AFGWheeledVehicle::OnRep_Info(){ }
void AFGWheeledVehicle::OnRep_TargetList(AFGDrivingTargetList* oldList){ }
void AFGWheeledVehicle::OnIsSimulatedChanged(){ }
FVector AFGWheeledVehicle::GetVelocityVector() const{ return FVector(); }
void AFGWheeledVehicle::OnSimulationTargetReached(AFGTargetPoint* newTarget){ }
AFGTargetPoint* AFGWheeledVehicle::SpawnNewTargetPoint(const FVector& location, const FRotator& rotation, AFGDrivingTargetList* targetList, int targetSpeed, AFGTargetPoint* afterTarget){ return nullptr; }
void AFGWheeledVehicle::StartGhosting(){ }
void AFGWheeledVehicle::TryLeaveSimulatedMode(){ }
bool AFGWheeledVehicle::IsAboveSolidGround(const FTransform& transform) const{ return bool(); }
AActor* AFGWheeledVehicle::IsOverlappingOther(const FTransform& transform) const{ return nullptr; }
void AFGWheeledVehicle::OnPathVisibilityChanged(bool pathVisibility){ }
float AFGWheeledVehicle::CalculateAutomatedFuelToConsume(float deltaTime){ return float(); }
void AFGWheeledVehicle::SetTargetList(AFGDrivingTargetList* targetList){ }
FName AFGWheeledVehicle::VehicleMeshComponentName = FName();
FName AFGWheeledVehicle::VehicleMovementComponentName = FName();
