using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace ImplementCSS_UEHeaders
{
    class Program
    {
        private static bool CountOnly = false;
        private static int FunctionCount;

        // TODO: Finish the c++ parser so that these workarounds can be replaced with something that doesn't require maintenance
        private static readonly string[] NeedsSuper = new string[] { "Serialize", "OnRegister", "OnUnregister", "PostLoad", "BeginDestroy", "PostInitProperties", "PostInitializeComponents", "CreateRenderState_Concurrent" };

        private static readonly Dictionary<string, string> CustomImplementation = new Dictionary<string, string>()
        {
            {
            "AFGBuildable::AFGBuildable",
@"  RootComponent = CreateDefaultSubobject<USceneComponent>(""RootComponent"");"
            },
            {
            "AFGBuildableConveyorBelt::AFGBuildableConveyorBelt",
@"	mSplineComponent = CreateDefaultSubobject<UFGSplineComponent>(TEXT(""SplineComponent""));

    mSplineComponent->SetupAttachment(RootComponent);"
            }
        };

        private static readonly Dictionary<string, string> NestedStructs = new Dictionary<string, string>()
        {
            {"ItemHolderHistory", "FConveyorBeltItems::ItemHolderHistory" },
            {"FGenerateIconContext", "UFGItemDescriptor::FGenerateIconContext" },
            {"Type", "FSaveCustomVersion::Type" }
        };

        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                args = new string[] { "", "", "" };
                Console.Write("Headers dir: ");
                args[0] = Console.ReadLine();
                Console.Write("Cpp file: ");
                args[1] = Console.ReadLine();
                Console.Write("Show only count? (y/N): ");
                args[2] = Console.ReadLine();
                if (args[2].ToLower() == "y" || args[2].ToLower() == "yes")
                    args[2] = "true";
                else
                    args[2] = "false";
            }
            if (args.Length >= 3)
                CountOnly = bool.Parse(args[2]);
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            Implement(args[0], args[1]);
            stopwatch.Stop();
            Console.WriteLine($"Done. Generated {FunctionCount} functions in {stopwatch.ElapsedMilliseconds} ms.");
        }

        private static void Implement(string path, string cppFile)
        {
            List<string> filesToInclude = new List<string>();
            List<string> implementations = new List<string>();
            foreach (string file in Directory.EnumerateFiles(path))
                if (file.EndsWith(".h"))
                {
                    implementations.AddRange(ImplementFile(file));
                    filesToInclude.Add(file);
                }
            using (StreamWriter writer = new StreamWriter($"{cppFile}.cpp"))
            {
                writer.WriteLine($"// This file has been automatically generated by the Unreal Header Implementation tool");
                writer.WriteLine($"");
                foreach (string file in filesToInclude)
                    writer.WriteLine($"#include \"{Path.GetFileName(file)}\"");
                writer.WriteLine($"");
                foreach (string func in implementations)
                    writer.WriteLine(func);
            }
        }

        private const string CSSRegex = @"(\s*)\/\/\s*<CSS>((?:.|\n)*?)^\1\/\/\s*<\/CSS>";

        private static List<string> ImplementFile(string filePath)
        {
            string fileContents;
            using (StreamReader reader = new StreamReader(filePath))
                fileContents = reader.ReadToEnd();
            List<string> implementations = new List<string>();
            foreach (Match cssEditMatch in Regex.Matches(fileContents, CSSRegex, RegexOptions.Multiline))
            {
                foreach (Match match in Regex.Matches(cssEditMatch.Value, @"^([ \t]*)(class|struct) ([^ ]*? )??([^ ]*?)( ?: ?.*?)?\s*{((?:.|\n)*?)^\1};", RegexOptions.Multiline)) // Match class/struct definition
                {
                    string className = match.Groups[4].Value;
                    string classContents = match.Groups[6].Value;
                    if (!IsValidClassName(className))
                        continue;
                    implementations.AddRange(ImplementClass(className, classContents, true));
                }
                fileContents.Replace(cssEditMatch.Value, "");
            }
            foreach (Match match in Regex.Matches(fileContents, @"^([ \t]*)(class|struct) ([^ ]*? )??([^ ]*?)( ?: ?.*?)?\s*{((?:.|\n)*?)^\1};", RegexOptions.Multiline)) // Match class/struct definition
            {
                string className = match.Groups[4].Value;
                string classContents = match.Groups[6].Value;
                if (!IsValidClassName(className))
                    continue;
                implementations.AddRange(ImplementClass(className, classContents));
            }
            return implementations;
        }

        private static List<string> ImplementClass(string className, string classContents, bool isCSS = false)
        {
            List<string> implementations = new List<string>();
            classContents = Regex.Replace(classContents, @"\/+\*(?:.|\s)*?\*\/", ""); // fix for comments containing brackets being matched as functions
            classContents = Regex.Replace(classContents, @"\/{2,}(?!</?CSS>).*", ""); // fix for comments causing some error
            classContents = Regex.Replace(classContents, @"\s*GENERATED.*?\(\)", ""); // fix for GENERATED... macros being matched
            classContents = Regex.Replace(classContents, @"\s*UPROPERTY ?\( ?(?:.|\s)*?;", ""); // fix for UPROPERTY... macros being matched
            classContents = Regex.Replace(classContents, @"\s*UE_DEPRECATED ?\( ?(?:.|\s)*?\)", ""); // fix for UE_DEPRECATED... macros being matched
            classContents = Regex.Replace(classContents, @"\s*DEPRECATED ?\( ?(?:.|\s)*?\)", ""); // fix for DEPRECATED... macros being matched
            // Implement with #if ... and delete it (fixes issues and requires less manual changes in the end)
            foreach (Match ifMacro in Regex.Matches(classContents, @"\s*#if (.*?)\n((?:.|\n)*?)\n?\s*#endif(.*)"))
            {
                string ifContents = ifMacro.Groups[2].Value;
                foreach (Match match in Regex.Matches(ifContents, @"^([ \t]*)(class|struct) ([^ ]*? )??([^ ]*?)( ?: ?.*?)?\s*{((?:.|\n)*?)^\1};", RegexOptions.Multiline)) // Match inner class/struct definition
                {
                    string innerClassName = match.Groups[4].Value;
                    string innerClassContents = match.Groups[6].Value;
                    if (!IsValidClassName(innerClassName))
                        continue;
                    implementations.AddRange(ImplementClass(className + "::" + innerClassName, innerClassContents, isCSS));
                    ifContents = ifContents.Replace(match.Value, "");
                }
                List<string> ifImplementations = new List<string>();
                ifImplementations.AddRange(ImplementFunctions(ifContents, className, isCSS));
                ifImplementations.AddRange(ImplementStaticVars(ifContents, className, isCSS));
                if (ifImplementations.Count > 0)
                {
                    implementations.Add($"#if {ifMacro.Groups[1].Value.Trim()}");
                    implementations.AddRange(ifImplementations);
                    implementations.Add($"#endif {ifMacro.Groups[3].Value.Trim()}");
                }
            }
            classContents = Regex.Replace(classContents, @"\s*#if\s(.*?)\n((?:.|\n)*?)\n\s*#endif(.*)", "");
            foreach (Match match in Regex.Matches(classContents, @"^([\s\t]*)(class|struct)\s([^\s]*?\s)??([^\s]*?)(\s?:\s?.*?)?\s*{((?:.|\n)*?)^\1};", RegexOptions.Multiline)) // Match inner class/struct definition
            {
                string innerClassName = match.Groups[4].Value;
                string innerClassContents = match.Groups[6].Value;
                if (!IsValidClassName(innerClassName))
                    continue;
                implementations.AddRange(ImplementClass(className + "::" + innerClassName, innerClassContents, isCSS));
                classContents = classContents.Replace(match.Value, "");
            }
            implementations.AddRange(ImplementFunctions(classContents, className, isCSS));
            implementations.AddRange(ImplementStaticVars(classContents, className, isCSS));
            return implementations;
        }

        private static List<string> ImplementStaticVars(string content, string className, bool isCSS = false)
        {
            List<string> implementations = new List<string>();
            if (!isCSS)
                foreach (Match cssEditMatch in Regex.Matches(content, CSSRegex, RegexOptions.Multiline))
                    implementations.AddRange(ImplementFunctions(cssEditMatch.Value, className, true));
            else
                foreach (Match function in Regex.Matches(content, @"(const\s)?static\s(const\s)?\s*([\w\d_]*?)\s+([\w\d_]*?);", RegexOptions.Multiline))
                {
                    string isConst = function.Groups[1].Value + function.Groups[2].Value;
                    string type = FixReturnType(function.Groups[3].Value).Trim();
                    string name = function.Groups[4].Value;
                    if (type.Contains("FAutoConsoleVariableSink")) // for this classes there is no constructor with no params, but NULL works
                        implementations.Add($"{isConst}{type} {className}::{name} = NULL;");
                    else // but NULL doesn't work for everything
                        implementations.Add($"{isConst}{type} {className}::{name} = {type}();");
                }
            return implementations;
        }

        private static List<string> ImplementFunctions(string content, string className, bool isCSS = false)
        {
            content = Regex.Replace(content, @"\r\n\s*public:", "\r\n");
            content = Regex.Replace(content, @"\r\n\s*private:", "\r\n");
            content = Regex.Replace(content, @"\r\n\s*protected:", "\r\n");
            List<string> implementations = new List<string>();
            if (!isCSS)
                foreach (Match cssEditMatch in Regex.Matches(content, CSSRegex, RegexOptions.Multiline))
                    implementations.AddRange(ImplementFunctions(cssEditMatch.Value, className, true));
            else
            {
                // Match function definition (including UFUNCTIONs), nothing to see here ... just walk away ... probably the reason for many missing implementations...
                foreach (Match function in Regex.Matches(content, @"^\s*(?:(UFUNCTION\s*\(.*?\))\s*)?(template\s*<\s*.*?>\s*)?(virtual\s?)?(static\s?)?(const\s?)?(class\s?)?(explicit\s?)?([^=()\n{}]*?_API\s)?([^=()\n{}]*?\s)?\n*((?:[^=<>()\n{}]|operator.+)*?)(\([^{}]*?\))(\s*const)?(\s*override)?(.*);", RegexOptions.Multiline))
                {
                    // string comment = function.Groups[1].Value; // removed because regex took too long
                    string ufunction = function.Groups[1].Value;
                    string template = function.Groups[2].Value;
                    string isVirtual = function.Groups[3].Value;
                    string isStatic = function.Groups[4].Value;
                    string isReturnConst = function.Groups[5].Value;
                    string isClass = function.Groups[6].Value;
                    string isExplicit = function.Groups[7].Value;
                    string api = function.Groups[8].Value;
                    string returnType = function.Groups[9].Value;
                    string functionName = function.Groups[10].Value;
                    string parameters = function.Groups[11].Value;
                    string isConst = function.Groups[12].Value;
                    string isOverride = function.Groups[13].Value;
                    string extras = function.Groups[14].Value;

                    if (extras.Contains("PURE_VIRTUAL")) // ignore pure virtual macro
                        continue;

                    if (!IsValidFunctionName(functionName) && !(functionName.Trim().Replace("~", "") == className && string.IsNullOrWhiteSpace(returnType)))
                        continue;

                    if (!string.IsNullOrWhiteSpace(template)) // All of them end up commented
                        continue;
                    // regex takes too long and it is the only other way to fix UPARAM's closing bracket being matched as parameter closing bracket...
                    int bracketCount = parameters.Count(ch => ch == '(') - parameters.Count(ch => ch == ')');
                    if (bracketCount > 0)
                    {
                        parameters += isConst + isOverride;
                        isConst = "";
                        isOverride = "";
                        while (bracketCount > 0)
                        {
                            parameters += extras[0];
                            if (extras[0] == '(')
                                bracketCount++;
                            if (extras[0] == ')')
                                bracketCount--;
                            extras = extras.Substring(1);
                        }
                        if (extras.Contains("const"))
                            isConst = " const";
                        if (extras.Contains("override"))
                            isConst = " override";
                    }


                    if (extras.Contains('{') || extras.Contains("delete") || extras.Contains("="))
                        continue; // already implemented in header and it matched "... { return ...; }"

                    parameters = Regex.Replace(parameters, @"\/\*.*?\*\/", ""); // fix for commented defaults
                    template = Regex.Replace(template, @"\/\*.*?\*\/", ""); // fix for commented defaults ?

                    if (!string.IsNullOrWhiteSpace(ufunction))
                    {
                        if (Regex.IsMatch(ufunction, @"\WBlueprintImplementableEvent\W"))
                        {
                            if (!CountOnly)
                                Console.WriteLine($"Skipped {className}::{functionName} (BlueprintImplementableEvent)");
                            continue;
                        }
                        if (Regex.IsMatch(ufunction, @"\WBlueprintNativeEvent\W") || Regex.IsMatch(ufunction, @"\WServer\W") || Regex.IsMatch(ufunction, @"\WClient\W") || Regex.IsMatch(ufunction, @"\WNetMulticast\W"))
                        {
                            if (Regex.IsMatch(ufunction, @"\WBlueprintNativeEvent\W") && className.Contains("Interface"))
                            {
                                if (!CountOnly)
                                    Console.WriteLine($"Skipped {className}::{functionName} (BlueprintNativeEvent in Interface)"); // https://answers.unrealengine.com/questions/832889/blueprintnativeevent-function-already-has-a-body.html
                                continue;
                            }
                            ImplementFunction(implementations, className, isClass, isReturnConst, returnType, functionName.Trim() + "_Implementation", parameters, isConst, template, isStatic);
                        }
                        else if (Regex.IsMatch(ufunction, @"\WBlueprintPure\W") || Regex.IsMatch(ufunction, @"\WBlueprintCallable\W") || Regex.IsMatch(ufunction.ToLower(), @"\Wexec\W") || Regex.Replace(TrimUselessSpaces(ufunction), @"( ?(?:Category ?= ?"".*?""|meta ?= ?"".*""|meta ?= ?\(.*?\))(?:,| )?)", "") == "UFUNCTION()")
                            ImplementFunction(implementations, className, isClass, isReturnConst, returnType, functionName, parameters, isConst, template, isStatic);
                        if (Regex.IsMatch(ufunction, @"\WWithValidation\W"))
                            ImplementFunction(implementations, className, isClass, isReturnConst, "bool ", functionName.Trim() + "_Validate", parameters, isConst, template, isStatic);
                    }
                    else
                        ImplementFunction(implementations, className, isClass, isReturnConst, returnType, functionName, parameters, isConst, template, isStatic);
                }
            }
            return implementations;
        }

        private static void ImplementFunction(List<string> implementations, string className, string isClass, string isReturnConst, string returnType, string functionName, string parameters, string isConst, string template, string isStatic)
        {
            string withoutDestructorThingy = functionName.Trim().Replace("~", "");
            string withoutOuterClass = className.Substring(className.LastIndexOf(":") + 1);
            if (IsValidReturnType(returnType) || (withoutDestructorThingy == withoutOuterClass && string.IsNullOrWhiteSpace(returnType)))
            {
                if (!string.IsNullOrWhiteSpace(template))
                    template = FixDefaults(template.Trim().TrimEnd('>')) + '>' + Environment.NewLine;
                string result = $"{template}{isReturnConst}{FixReturnType(returnType)}{className}::{functionName}({Regex.Replace(FixDefaults(parameters.Trim().TrimEnd(')')), @"(?<!<)\b(class|struct)\b", "")}){isConst}";
                if (parameters.Contains("objectInitializer") && withoutDestructorThingy == className) // if it is constructor of derived class
                    result += " : Super(objectInitializer) ";
                else if (parameters.Contains("ObjectInitializer") && withoutDestructorThingy == className) // if it is constructor of derived class
                    result += " : Super(ObjectInitializer) ";
                if (parameters.Replace(" ", "").Contains("FArchive&inInnerArchive")) 
                     result += " : FArchiveProxy(inInnerArchive) ";
                if (parameters.Replace(" ", "").Contains("UCharacterMovementComponent"))
                    result += " : FNetworkPredictionData_Client_Character(clientMovement) ";
                if (functionName.Replace(" ", "").Contains("FObjectReader"))
                    result += " : FObjectReader(Obj, InBytes) ";
                if (functionName.Replace(" ", "").Contains("FObjectWriter"))
                    result += " : FObjectWriter(Obj, InBytes) ";
                result += $"{{ ";
                if (CustomImplementation.ContainsKey($"{className}::{functionName}")) // aghhhh
                    result += $"\r\n{CustomImplementation[$"{className}::{functionName}"]}\r\n}}";
                else
                {
                    if (returnType.Contains("void") || string.IsNullOrWhiteSpace(returnType))
                    {
                        if (NeedsSuper.Contains(functionName.Trim()))
                            result += $"Super::{functionName}({string.Join(",", Regex.Matches(FixDefaults(parameters), @"(?:.*? )?(.*?) (.*?)(?:, ?|\)|$)").Cast<Match>().Select(match => match.Groups[2].Value))}); ";
                        result += $"}}";
                    }
                    else
                    {
                        result += $"return ";
                        if (returnType.Trim().EndsWith("&"))
                            if (returnType.Trim().TrimEnd('&') == className)
                                result += $"*(this)";
                            else
                                result += $"*(new {returnType.Trim().TrimEnd('&')})"; // Brabb3l's life-hacks
                        else if (returnType.Trim().EndsWith("*"))
                            result += $"nullptr";
                        else
                            result += $"{GetCustomReturn(returnType)}";
                        result += $"; }}";
                    }
                }
                if (!implementations.Contains(result))
                    implementations.Add(result);
                if(!CountOnly)
                    Console.WriteLine($"Generated {className}::{functionName}");
                FunctionCount++;
            }
        }

        private static bool IsValidClassName(string className)
        {
            return Regex.Match(className, @"^[\w\d_]+$").Success;
        }

        private static bool IsValidFunctionName(string functionName)
        {
            return Regex.Match(functionName.Trim(), @"^([\w\d_~]+|operator.+)$").Success && !(new string[] { "return", "if", "else", "const", "struct", "for" /* fill with more as they show up */ }).Contains(functionName.Trim()) && !IsAllCaps(functionName.Trim()); // Don't match macros
        }

        private static string FixReturnType(string returnType)
        {
            returnType = returnType.Trim();
            if (returnType.EndsWith("*"))
            {
                if (NestedStructs.ContainsKey(returnType.TrimEnd('*')))
                    return NestedStructs[returnType.TrimEnd('*')] + "* ";
            }
            else if (returnType.EndsWith("&"))
            {
                if (NestedStructs.ContainsKey(returnType.TrimEnd('&')))
                    return NestedStructs[returnType.TrimEnd('&')] + "& ";
            }
            else
            {
                if (NestedStructs.ContainsKey(returnType))
                    return NestedStructs[returnType] + " ";
            }
            if(!string.IsNullOrWhiteSpace(returnType))
                return returnType.Trim() + " ";
            return "";
        }

        private static string GetCustomReturn(string returnType)
        {
            returnType = TrimUselessSpaces(returnType); // trim spaces between < and character, ( and character, etc.
            switch (returnType)
            {
                case "FReply":
                    return "FReply::Unhandled()";
                case "TSharedRef<SWidget>":
                    return "Super::RebuildWidget()";
                default:
                    return $"{returnType}()";
            }
        }

        private static string TrimUselessSpaces(string str)
        {
            return Regex.Replace(str.Trim(), @"(?:([^\w\d])\s+([\w\d])|([\w\d])\s+([^\w\d])|([^\w\d])\s+([^\w\d]))", "$1$2$3$4$5$6");
        }

        private static string FixDefaults(string parameters)
        {
            string ret = string.Join(",", parameters.Trim().TrimStart('(').TrimEnd(')').Split(',').Select(param => param.Trim().Contains("UPARAM") ? param : param.Split('=')[0]));
            return ret;
        }

        private static bool IsAllCaps(string str)
        {
            return !Regex.Match(str, "[a-z]").Success && !string.IsNullOrWhiteSpace(str);
        }

        private static bool IsValidReturnType(string returnType)
        {
            return !(new string[] { "return", "if", "else", "const", "struct", "for" /* fill with more as they show up */ }).Contains(returnType.Trim()) && !IsAllCaps(returnType) && !string.IsNullOrWhiteSpace(returnType) && !returnType.Contains("FORCEINLINE") && !returnType.Contains("+"); // FORCEINLINE are already implemented in header (?)
        }
    }
}
