// This file has been automatically generated by the Unreal Header Implementation tool

#include "Hologram/FGHologram.h"
#include "AkAudio/Classes/AkComponent.h"
#include "Components/SceneComponent.h"
#include "Net/UnrealNetwork.h"

TAutoConsoleVariable<int32> CVarHologramDebug(TEXT("CVarHologramDebug"), 0, TEXT(""));
AFGHologram::AFGHologram() : Super() {
	this->mRecipe = nullptr;
	this->mLoopSound = CreateDefaultSubobject<UAkComponent>(TEXT("LoopSound"));
	this->mClearanceBox = nullptr;
	this->mClearanceMeshComponent = nullptr;
	this->mClearanceDetector = nullptr;
	this->mShouldCreateClearanceMeshVisual = true;
	this->mSoftClearanceOverlapResponse = EHologramSoftClearanceResponse::HSCR_Default;
	this->mBuildModeCategory = EHologramBuildModeCategory::HBMC_ActorClass;
	this->mDefaultBuildMode = nullptr;
	this->mPlacementMaterialState = EHologramMaterialState::HMS_OK;
	this->mValidPlacementMaterial = nullptr;
	this->mInvalidPlacementMaterial = nullptr;
	this->mParent = nullptr;
	this->mBuildClass = nullptr;
	this->mUseBuildClearanceOverlapSnapp = false;
	this->mBlueprintDesigner = nullptr;
	this->mAllowEdgePlacementInDesignerEvenOnIntersect = false;
	this->mCanBePlacedInBlueprintDesigner = false;
	this->mCanLockHologram = true;
	this->mCanNudgeHologram = false;
	this->mDefaultNudgeDistance = 100.0;
	this->mMaxNudgeDistance = 800.0;
	this->mConstructionInstigator = nullptr;
	this->mIsDisabled = false;
	this->mIsChanged = false;
	this->mConstructionPosition = FVector::ZeroVector;
	this->mConstructionRotation = FRotator::ZeroRotator;
	this->SetHidden(true);
	this->bReplicates = true;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("RootComponent"));
	this->mLoopSound->SetupAttachment(RootComponent);
}
void AFGHologram::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGHologram, mRecipe);
	DOREPLIFETIME(AFGHologram, mScrollRotation);
	DOREPLIFETIME(AFGHologram, mPlacementMaterialState);
	DOREPLIFETIME(AFGHologram, mBuildClass);
	DOREPLIFETIME(AFGHologram, mConstructionInstigator);
	DOREPLIFETIME(AFGHologram, mIsChanged);
}
bool AFGHologram::IsNetRelevantFor(const AActor* RealViewer, const AActor* ViewTarget, const FVector& SrcLocation) const{ return bool(); }
AFGHologram* AFGHologram::SpawnHologramFromRecipe(TSubclassOf<  UFGRecipe > inRecipe, AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ return nullptr; }
AFGHologram* AFGHologram::SpawnChildHologramFromRecipe(AFGHologram* parent, TSubclassOf< UFGRecipe > recipe, AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ return nullptr; }
void AFGHologram::SetRecipe(TSubclassOf<  UFGRecipe > recipe){ }
TSubclassOf< class UFGItemDescriptor > AFGHologram::GetItemDescriptor() const{ return TSubclassOf<class UFGItemDescriptor>(); }
void AFGHologram::SerializeOntoConstructHologramMessage(FConstructHologramMessage& message){ }
void AFGHologram::DeserializeFromConstructHologramMessage(FConstructHologramMessage& message,  AFGBuildGun* buildGun){ }
void AFGHologram::SerializeConstructMessage(FArchive& ar, FNetConstructionID id){ }
void AFGHologram::ClientPreConstructMessageSerialization(){ }
void AFGHologram::ServerPostConstructMessageDeserialization(){ }
void AFGHologram::OnConstructMessagedDeserialized_Implementation(){ }
void AFGHologram::BeginPlay(){ }
void AFGHologram::Destroyed(){ }
void AFGHologram::SetActorHiddenInGame(bool newHidden){ }
bool AFGHologram::IsValidHitResult(const FHitResult& hitResult) const{ return bool(); }
bool AFGHologram::TryUpgrade(const FHitResult& hitResult){ return bool(); }
void AFGHologram::AdjustForGround(FVector& out_adjustedLocation, FRotator& out_adjustedRotation){ }
bool AFGHologram::TrySnapToActor(const FHitResult& hitResult){ return bool(); }
void AFGHologram::SetHologramLocationAndRotation(const FHitResult& hitResult){ }
void AFGHologram::PreHologramPlacement(const FHitResult& hitResult){ }
void AFGHologram::PostHologramPlacement(const FHitResult& hitResult){ }
void AFGHologram::OnInvalidHitResult(){ }
void AFGHologram::SetHologramNudgeLocation(){ }
void AFGHologram::ValidatePlacementAndCost( UFGInventoryComponent* inventory){ }
bool AFGHologram::DoMultiStepPlacement(bool isInputFromARelease){ return bool(); }
void AFGHologram::Scroll(int32 delta){ }
void AFGHologram::ScrollRotate(int32 delta, int32 step){ }
int32 AFGHologram::GetScrollRotateValue() const{ return int32(); }
void AFGHologram::SetScrollRotateValue(int32 rotValue){ }
void AFGHologram::ReplaceHologram(AFGHologram* hologram, bool snapTransform){ }
void AFGHologram::GetSupportedBuildModes_Implementation(TArray< TSubclassOf< UFGBuildGunModeDescriptor > >& out_buildmodes) const{ }
bool AFGHologram::IsCurrentBuildMode(TSubclassOf<UFGHologramBuildModeDescriptor> buildMode) const{ return bool(); }
void AFGHologram::OnBuildModeChanged(TSubclassOf<UFGHologramBuildModeDescriptor> buildMode){ }
void AFGHologram::SetSnapToGuideLines(bool isEnabled){ }
void AFGHologram::SetPlacementMaterialState(EHologramMaterialState materialState){ }
EHologramMaterialState AFGHologram::GetHologramMaterialState() const{ return EHologramMaterialState(); }
float AFGHologram::GetBuildGunRangeOverride_Implementation() const{ return float(); }
bool AFGHologram::IsChanged() const{ return bool(); }
AActor* AFGHologram::GetUpgradedActor() const{ return nullptr; }
bool AFGHologram::CanConstruct() const{ return bool(); }
bool AFGHologram::CanTakeNextBuildStep() const{ return bool(); }
AActor* AFGHologram::Construct(TArray< AActor* >& out_children, FNetConstructionID constructionID){ return nullptr; }
void AFGHologram::OnPendingConstructionHologramCreated_Implementation( AFGHologram* fromHologram){ }
void AFGHologram::OnHologramTimeout(){ }
TArray< FItemAmount > AFGHologram::GetBaseCost() const{ return TArray<FItemAmount>(); }
int32 AFGHologram::GetBaseCostMultiplier() const{ return int32(); }
TArray< FItemAmount > AFGHologram::GetCost(bool includeChildren) const{ return TArray<FItemAmount>(); }
void AFGHologram::GetIgnoredClearanceActors(TArray< AActor* >& ignoredActors) const{ }
void AFGHologram::SetDisabled(bool disabled){ }
bool AFGHologram::IsDisabled() const{ return bool(); }
void AFGHologram::SpawnChildren(AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ }
void AFGHologram::AddChild(AFGHologram* child){ }
void AFGHologram::AddConstructDisqualifier(TSubclassOf<  UFGConstructDisqualifier > disqualifier){ }
void AFGHologram::GetConstructDisqualifiers(TArray< TSubclassOf<  UFGConstructDisqualifier > >& out_constructResults) const{ }
void AFGHologram::ResetConstructDisqualifiers(){ }
void AFGHologram::UpdateRotationValuesFromTransform(){ }
void AFGHologram::SetBuildClass(TSubclassOf<  AActor > buildClass){ }
TSubclassOf< AActor > AFGHologram::GetActorClass() const{ return TSubclassOf<AActor>(); }
void AFGHologram::SetInsideBlueprintDesigner( AFGBuildableBlueprintDesigner* designer){ }
AFGBuildableBlueprintDesigner* AFGHologram::GetBlueprintDesigner(){ return nullptr; }
bool AFGHologram::CanNudgeHologram() const{ return bool(); }
void AFGHologram::LockHologramPosition(bool lock){ }
void AFGHologram::SetNudgeOffset(const FVector& NewNudgeOffset){ }
ENudgeFailReason AFGHologram::AddNudgeOffset(const FVector& Offset){ return ENudgeFailReason(); }
float AFGHologram::GetNudgeDistance() const{ return float(); }
ENudgeFailReason AFGHologram::NudgeTowardsWorldDirection(const FVector& Direction){ return ENudgeFailReason(); }
ENudgeFailReason AFGHologram::NudgeHologram(const FVector& NudgeInput, const FHitResult& HitResult){ return ENudgeFailReason(); }
AFGHologram* AFGHologram::GetNudgeHologramTarget(){ return nullptr; }
void AFGHologram::OnHologramTransformUpdated(){ }
void AFGHologram::SetupClearance( UFGClearanceComponent* clearanceComponent){ }
void AFGHologram::SetupClearanceDetector( UFGClearanceComponent* clearanceComponent){ }
void AFGHologram::CheckClearance(const FVector& locationOffset){ }
void AFGHologram::HandleClearanceOverlap(const FOverlapResult& overlap, const FVector& locationOffset, bool HologramHasSoftClearance){ }
bool AFGHologram::IsHologramIdenticalToActor(AActor* actor, const FVector& hologramLocationOffset) const{ return bool(); }
bool AFGHologram::CanIntersectWithDesigner( AFGBuildableBlueprintDesigner* designer){ return bool(); }
UPrimitiveComponent* AFGHologram::GetClearanceOverlapCheckComponent() const{ return nullptr; }
void AFGHologram::CheckValidPlacement(){ }
void AFGHologram::CheckCanAfford( UFGInventoryComponent* inventory){ }
void AFGHologram::OnSnap(){ }
void AFGHologram::OnRep_PlacementMaterialState(){ }
void AFGHologram::SetMaterial( UMaterialInterface* material){ }
void AFGHologram::SetMaterialState(EHologramMaterialState state){ }
uint8 AFGHologram::GetStencilForHologramMaterialState(EHologramMaterialState state) const{ return uint8(); }
USceneComponent* AFGHologram::SetupComponent(USceneComponent* attachParent, UActorComponent* componentTemplate, const FName& componentName, const FName& attachSocketName){ return nullptr; }
TArray<UStaticMeshComponent*> AFGHologram::SpawnLightWeightInstanceData(USceneComponent* attachParent){ return TArray<UStaticMeshComponent*>(); }
void AFGHologram::SetIsChanged(bool isChanged){ }
bool AFGHologram::IsLocalHologram() const{ return bool(); }
bool AFGHologram::IsValidHitActor(AActor* hitActor) const{ return bool(); }
int32 AFGHologram::GetRotationStep() const{ return int32(); }
float AFGHologram::ApplyScrollRotationTo(float base, bool onlyUseBaseForAlignment) const{ return float(); }
FVector AFGHologram::GetMaxNudgeDistance() const{ return FVector(); }
AFGHologram* AFGHologram::SpawnHologramFromRecipe(TSubclassOf<  UFGRecipe > inRecipe, AFGHologram* parent, AActor* hologramOwner, FVector spawnLocation, APawn* hologramInstigator){ return nullptr; }
void AFGHologram::SetupComponents(){ }
void AFGHologram::Client_PlaySnapSound_Implementation(){ }
const FName AFGHologram::HOLOGRAM_MESH_TAG = FName();
