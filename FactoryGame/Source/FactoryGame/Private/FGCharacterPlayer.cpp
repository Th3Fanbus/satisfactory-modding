// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGCharacterPlayer.h"
#include "Components/CapsuleComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "Components/WidgetComponent.h"
#include "FGOutlineComponent.h"
#include "GameFramework/SpringArmComponent.h"
#include "Net/UnrealNetwork.h"
#include "FGCharacterMovementComponent.h"

AFGCharacterPlayer::AFGCharacterPlayer(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer.SetDefaultSubobjectClass<UFGCharacterMovementComponent>(ACharacter::CharacterMovementComponentName)) {
	this->mFlyToggleTime = 0.2;
	this->mBaseTurnRate = 45.0;
	this->mBaseLookUpRate = 45.0;
	this->mMesh1PAnimClass = nullptr;
	this->mMesh3P = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("CharacterMesh3P"));
	this->mPlayerNameWidgetComponent = CreateDefaultSubobject<UWidgetComponent>(TEXT("PlayerNameWidget"));
	this->mFoliagePickupProxyClass = nullptr;
	this->mFoliagePickupProxy = nullptr;
	this->mBuildGun = nullptr;
	this->mResourceScanner = nullptr;
	this->mResourceMiner = nullptr;
	this->mWaitingClientAttachDrivable = nullptr;
	this->mBestUsableActor = nullptr;
	this->mAnimInstanceClass = nullptr;
	this->mAnimInstanceClass1P = nullptr;
	this->mReviveDuration = 5.0;
	this->mDrownDamageInterval = 1.0;
	this->mPlayerToRevive = nullptr;
	this->mPickupToCollect = nullptr;
	this->m1PDefaultFootstepEffect.Particle = nullptr;
	this->mLastSafeGroundPositions[0] = FVector::ZeroVector;
	this->mLastSafeGroundPositions[1] = FVector::ZeroVector;
	this->mLastSafeGroundPositions[2] = FVector::ZeroVector;
	this->mHazmatSuitClass = nullptr;
	this->mCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(" PlayerCamera "));
	this->mIsCheatFlyingSaved = false;
	this->mCinematicCameraComponent = nullptr;
	this->mSpringArmComponent = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraSpringArm"));
	this->mCameraComponent->SetupAttachment(mSpringArmComponent);
	this->mCurrentCameraMode = ECameraMode::ECM_None;
	this->mPlayerPreferredCameraMode = ECameraMode::ECM_FirstPerson;
	this->mInventory = nullptr;
	this->mArmsEquipmentSlot = nullptr;
	this->mBackEquipmentSlot = nullptr;
	this->mLegsEquipmentSlot = nullptr;
	this->mHeadEquipmentSlot = nullptr;
	this->mBodyEquipmentSlot = nullptr;
	this->mAllowedResourceFormsInInventory.Add(EResourceForm::RF_SOLID);
	this->mTrashSlot = nullptr;
	this->mAllowCameraToggling = false;
	this->mUseDistance = 450.0;
	this->mReviver = nullptr;
	this->mDefaultWalkHeadBobCameraAnim = nullptr;
	this->mDefaultSprintHeadBobCameraAnim = nullptr;
	this->mDrivenVehicle = nullptr;
	this->mSavedDrivenVehicle = nullptr;
	this->mOutlineComponent = CreateDefaultSubobject<UFGOutlineComponent>(TEXT("OutlineComponent"));
	this->mHealthGenerationWaitTime = 3.0;
	this->mHealthGenerationRateOverHealthAmount.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mHealthGenerationRateOverHealthAmount.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mHealthGenerationRateOverHealthAmount.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mHealthGenerationRateOverHealthAmount.ExternalCurve = nullptr;
	this->mRadiationIntensity = 0.0;
	this->mRadiationDamageAngle = 0.0;
	this->mRadiationImmunity = 0.0;
	this->mInRadioactiveZone = false;
	this->mCameraOffsetBlendSpeed = 3.0;
	this->mReplicatedIsSliding = false;
	this->mSlideNoise = nullptr;
	this->mSlideNoiseFrequency = 0.2;
	this->mCrouchSpeed = 3.0;
	this->mStandSpeed = 3.0;
	this->mSlideToCrouchSpeed = 1.0;
	this->mZiplineParticle = nullptr;
	this->mCurrentEmote = nullptr;
	this->mCurrentEmoteSFX = nullptr;
	this->mEmoteMenuWidget = nullptr;
	this->mEmoteSkelMeshComp = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT("EmoteSkelMeshComp"));
	this->mActorRepresentationTexture = nullptr;
	this->mActorRepresentationTextureDead = nullptr;
	this->mCachedActorRepresentation = nullptr;
	this->mHolsteredEquipmentIndex = -1;
	this->mCachedPlayerName = TEXT("");
	this->mPendingHyperJunctionOutputConnection.ConnectionEnteredThrough = nullptr;
	this->mPendingHyperJunctionOutputConnection.PickedOutputConnection = nullptr;
	this->bNetUseOwnerRelevancy = true;
	this->mMesh3P->SetupAttachment(GetCapsuleComponent());
	this->mPlayerNameWidgetComponent->SetupAttachment(GetCapsuleComponent());
	this->mSpringArmComponent->SetupAttachment(GetCapsuleComponent());
	this->mEmoteSkelMeshComp->SetupAttachment(GetCapsuleComponent());
}
void AFGCharacterPlayer::GetLifetimeReplicatedProps(TArray< FLifetimeProperty >& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGCharacterPlayer, mFoliagePickupProxy);
	DOREPLIFETIME(AFGCharacterPlayer, mBuildGun);
	DOREPLIFETIME(AFGCharacterPlayer, mResourceScanner);
	DOREPLIFETIME(AFGCharacterPlayer, mResourceMiner);
	DOREPLIFETIME(AFGCharacterPlayer, mWaitingClientAttachDrivable);
	DOREPLIFETIME(AFGCharacterPlayer, mActorPerceptionInfo);
	DOREPLIFETIME(AFGCharacterPlayer, mActiveEquipments);
	DOREPLIFETIME(AFGCharacterPlayer, mAllAttachments);
	DOREPLIFETIME(AFGCharacterPlayer, mActiveAttachments);
	DOREPLIFETIME(AFGCharacterPlayer, mInventory);
	DOREPLIFETIME(AFGCharacterPlayer, mArmsEquipmentSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mBackEquipmentSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mLegsEquipmentSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mHeadEquipmentSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mBodyEquipmentSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mTrashSlot);
	DOREPLIFETIME(AFGCharacterPlayer, mPickupCounter);
	DOREPLIFETIME(AFGCharacterPlayer, mDrivenVehicle);
	DOREPLIFETIME(AFGCharacterPlayer, mRadiationIntensity);
	DOREPLIFETIME(AFGCharacterPlayer, mRadiationDamageAngle);
	DOREPLIFETIME(AFGCharacterPlayer, mRadiationImmunity);
	DOREPLIFETIME(AFGCharacterPlayer, mInRadioactiveZone);
	DOREPLIFETIME(AFGCharacterPlayer, mReplicatedIsSliding);
	DOREPLIFETIME(AFGCharacterPlayer, mIncomingAttackers);
	DOREPLIFETIME(AFGCharacterPlayer, mHolsteredEquipmentIndex);
	DOREPLIFETIME(AFGCharacterPlayer, mCachedPlayerName);
	DOREPLIFETIME(AFGCharacterPlayer, mPendingHyperJunctionOutputConnection);
}
void AFGCharacterPlayer::PostActorCreated(){ Super::PostActorCreated(); }
void AFGCharacterPlayer::PostInitializeComponents(){ Super::PostInitializeComponents(); }
void AFGCharacterPlayer::BeginPlay(){ }
void AFGCharacterPlayer::EndPlay(const EEndPlayReason::Type endPlayReason){ }
void AFGCharacterPlayer::Tick(float deltaTime){ }
bool AFGCharacterPlayer::CanBeBaseForCharacter(APawn* Pawn) const{ return bool(); }
void AFGCharacterPlayer::Destroyed(){ }
bool AFGCharacterPlayer::IsLocallyControlled() const{ return bool(); }
void AFGCharacterPlayer::PossessedBy(AController* newController){ }
void AFGCharacterPlayer::UnPossessed(){ }
void AFGCharacterPlayer::OnRep_Controller(){ }
void AFGCharacterPlayer::AddControllerPitchInput(float Val){ }
void AFGCharacterPlayer::Jump(){ }
void AFGCharacterPlayer::OnJumped_Implementation(){ }
FVector AFGCharacterPlayer::GetPawnViewLocation() const{ return FVector(); }
bool AFGCharacterPlayer::CanJumpInternal_Implementation() const{ return bool(); }
bool AFGCharacterPlayer::ShouldTakeDamage(float Damage, FDamageEvent const& DamageEvent, AController* EventInstigator, AActor* DamageCauser) const{ return bool(); }
void AFGCharacterPlayer::OnStartCrouch(float HeightAdjust, float ScaledHeightAdjust){ }
void AFGCharacterPlayer::OnEndCrouch(float HeightAdjust, float ScaledHeightAdjust){ }
void AFGCharacterPlayer::Died(AActor* died){ }
const FFootstepEffect& AFGCharacterPlayer::GetFootstepEffect(const FHitResult& hitResult) const{ return *(new FFootstepEffect); }
void AFGCharacterPlayer::OnTakeDamage(AActor* damagedActor, float damageAmount, const  UDamageType* damageType,  AController* instigatedBy, AActor* damageCauser){ }
void AFGCharacterPlayer::OnMovementModeChanged(EMovementMode PrevMovementMode, uint8 PreviousCustomMode){ }
bool AFGCharacterPlayer::CanCrouch() const{ return bool(); }
void AFGCharacterPlayer::UpdateUseState_Implementation( AFGCharacterPlayer* byCharacter, const FVector& atLocation,  UPrimitiveComponent* componentHit, FUseState& out_useState){ }
void AFGCharacterPlayer::OnUse_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGCharacterPlayer::OnUseStop_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
bool AFGCharacterPlayer::IsUseable_Implementation() const{ return bool(); }
void AFGCharacterPlayer::StartIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
FText AFGCharacterPlayer::GetLookAtDecription_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state) const{ return FText(); }
void AFGCharacterPlayer::StopIsLookedAt_Implementation( AFGCharacterPlayer* byCharacter, const FUseState& state){ }
void AFGCharacterPlayer::ReceiveRadiation_Implementation(float amount, float duration, FVector direction, TSubclassOf< UFGDamageType > damageType){ }
bool AFGCharacterPlayer::CanReceiveRadiation_Implementation() const{ return bool(); }
bool AFGCharacterPlayer::ShouldSave_Implementation() const{ return bool(); }
void AFGCharacterPlayer::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
void AFGCharacterPlayer::PreSaveGame_Implementation(int32 saveVersion, int32 gameVersion){ }
bool AFGCharacterPlayer::AddAsRepresentation(){ return bool(); }
bool AFGCharacterPlayer::UpdateRepresentation(){ return bool(); }
bool AFGCharacterPlayer::RemoveAsRepresentation(){ return bool(); }
bool AFGCharacterPlayer::IsActorStatic(){ return bool(); }
FVector AFGCharacterPlayer::GetRealActorLocation(){ return FVector(); }
FRotator AFGCharacterPlayer::GetRealActorRotation(){ return FRotator(); }
UTexture2D* AFGCharacterPlayer::GetActorRepresentationTexture(){ return nullptr; }
FText AFGCharacterPlayer::GetActorRepresentationText(){ return FText(); }
void AFGCharacterPlayer::SetActorRepresentationText(const FText& newText){ }
FLinearColor AFGCharacterPlayer::GetActorRepresentationColor(){ return FLinearColor(); }
void AFGCharacterPlayer::SetActorRepresentationColor(FLinearColor newColor){ }
ERepresentationType AFGCharacterPlayer::GetActorRepresentationType(){ return ERepresentationType(); }
bool AFGCharacterPlayer::GetActorShouldShowInCompass(){ return bool(); }
bool AFGCharacterPlayer::GetActorShouldShowOnMap(){ return bool(); }
EFogOfWarRevealType AFGCharacterPlayer::GetActorFogOfWarRevealType(){ return EFogOfWarRevealType(); }
float AFGCharacterPlayer::GetActorFogOfWarRevealRadius(){ return float(); }
ECompassViewDistance AFGCharacterPlayer::GetActorCompassViewDistance(){ return ECompassViewDistance(); }
void AFGCharacterPlayer::SetActorCompassViewDistance(ECompassViewDistance compassViewDistance){ }
void AFGCharacterPlayer::OnPossessedSetup(){ }
bool AFGCharacterPlayer::IsInStartingPod() const{ return bool(); }
void AFGCharacterPlayer::RegisterPerceivingActor( AActor* actor){ }
void AFGCharacterPlayer::UnregisterPerceivingActor( AActor* actor){ }
void AFGCharacterPlayer::OnPerceivingCreatureStateChange( AFGCreatureController* creatureController, ECreatureState previousState, ECreatureState newState){ }
const FFGActorPlayerPerceptionInfo* AFGCharacterPlayer::GetPerceptionInfoForActor( AActor* actor) const{ return nullptr; }
void AFGCharacterPlayer::EquipEquipment(AFGEquipment* equipment){ }
void AFGCharacterPlayer::UnequipEquipment(AFGEquipment* equipment){ }
void AFGCharacterPlayer::ToggleEquipment(){ }
void AFGCharacterPlayer::SetOverrideEquipment(AFGEquipment* equipment){ }
void AFGCharacterPlayer::ClearOverrideEquipment(AFGEquipment* equipment){ }
void AFGCharacterPlayer::Server_SetOverrideEquipment_Implementation(AFGEquipment* equipment){ }
void AFGCharacterPlayer::Server_ClearOverrideEquipment_Implementation(AFGEquipment* equipment){ }
void AFGCharacterPlayer::Multicast_SetOverrideEquipment_Implementation(AFGEquipment* equipment){ }
void AFGCharacterPlayer::Multicast_ClearOverrideEquipment_Implementation(AFGEquipment* equipment){ }
TArray< AFGEquipment* > AFGCharacterPlayer::GetActiveEquipments() const{ return TArray<AFGEquipment*>(); }
TArray< class AFGEquipmentAttachment* > AFGCharacterPlayer::GetActiveAttachments() const{ return TArray<class AFGEquipmentAttachment*>(); }
ECrosshairState AFGCharacterPlayer::GetActiveCrosshairState(){ return ECrosshairState(); }
UFGInventoryComponentEquipment* AFGCharacterPlayer::GetEquipmentSlot(EEquipmentSlot slot) const{ return nullptr; }
AFGEquipment* AFGCharacterPlayer::GetEquipmentInSlot(EEquipmentSlot slot) const{ return nullptr; }
FInventoryItem AFGCharacterPlayer::GetActiveEquipmentItem(EEquipmentSlot slot) const{ return FInventoryItem(); }
bool AFGCharacterPlayer::CanEquipBuildGun() const{ return bool(); }
bool AFGCharacterPlayer::CanEquipBuildGunForDismantle() const{ return bool(); }
bool AFGCharacterPlayer::CanEquipBuildGunForPaint() const{ return bool(); }
bool AFGCharacterPlayer::IsBuildGunEquipped() const{ return bool(); }
void AFGCharacterPlayer::ToggleBuildGun(){ }
bool AFGCharacterPlayer::UnequipBuildGun(){ return bool(); }
void AFGCharacterPlayer::ToggleBuildGunPaint(){ }
void AFGCharacterPlayer::HotKeyRecipe(TSubclassOf<  UFGRecipe > recipe){ }
void AFGCharacterPlayer::HotKeyDismantle(){ }
void AFGCharacterPlayer::HotKeyPaint(TSubclassOf<  UFGCustomizationRecipe > customization){ }
void AFGCharacterPlayer::HotKeyBlueprint(const FString& blueprintName){ }
USkeletalMeshComponent* AFGCharacterPlayer::GetMesh3P() const{ return nullptr; }
USkeletalMeshComponent* AFGCharacterPlayer::GetMainMesh() const{ return nullptr; }
void AFGCharacterPlayer::ToggleCameraMode(bool force){ }
void AFGCharacterPlayer::Photo_SetAdvancedPhotoMode(bool enabled){ }
void AFGCharacterPlayer::Photo_ToggleAdvancedPhotoMode(){ }
void AFGCharacterPlayer::StartFocusAim_Implementation(){ }
void AFGCharacterPlayer::StopFocusAim_Implementation(){ }
void AFGCharacterPlayer::StartFreeRotate3P_Implementation(){ }
void AFGCharacterPlayer::StopFreeRotate3P_Implementation(){ }
void AFGCharacterPlayer::CameraZoomIn_Implementation(){ }
void AFGCharacterPlayer::CameraZoomOut_Implementation(){ }
void AFGCharacterPlayer::SetFirstPersonMode_Implementation(){ }
void AFGCharacterPlayer::SetThirdPersonMode_Implementation(){ }
void AFGCharacterPlayer::SetCameraMode(const ECameraMode newCameraMode){ }
void AFGCharacterPlayer::UsePreferredCameraMode(){ }
bool AFGCharacterPlayer::IsFirstPerson() const{ return bool(); }
void AFGCharacterPlayer::TickCameraOffset(float dt){ }
void AFGCharacterPlayer::Server_CycleHandEquipmentPressed_Implementation(int32 dir){ }
bool AFGCharacterPlayer::Server_CycleHandEquipmentPressed_Validate(int32 dir){ return bool(); }
void AFGCharacterPlayer::DoCycleEquipment(int32 dir){ }
void AFGCharacterPlayer::StartDriving( AFGDriveablePawn* vehicle){ }
void AFGCharacterPlayer::StopDriving( AFGDriveablePawn* vehicle){ }
UFGGameUI* AFGCharacterPlayer::GetGameUI() const{ return nullptr; }
void AFGCharacterPlayer::TrySpawnInitialGear(){ }
void AFGCharacterPlayer::SpawnInitialGear_Implementation(){ }
void AFGCharacterPlayer::OnPickUpItem(){ }
void AFGCharacterPlayer::PickUpItem( AFGItemPickup* itemPickup){ }
void AFGCharacterPlayer::PickUpBoomBox( AFGBoomBoxPlayer* boomBox){ }
void AFGCharacterPlayer::SetPickupToCollect( AFGItemPickup* itemPickup){ }
AFGResourceMiner* AFGCharacterPlayer::GetActiveResourceMiner() const{ return nullptr; }
void AFGCharacterPlayer::Server_ToggleSwitchControl_Implementation( AFGBuildableRailroadSwitchControl* switchControl){ }
bool AFGCharacterPlayer::Server_ToggleSwitchControl_Validate( AFGBuildableRailroadSwitchControl* switchControl){ return bool(); }
void AFGCharacterPlayer::TickDrownDamage(float delta){ }
void AFGCharacterPlayer::TickHealthGeneration(float delta){ }
UFGLadderComponent* AFGCharacterPlayer::GetCurrentLadderComponent() const{ return nullptr; }
UCameraAnimationSequence* AFGCharacterPlayer::GetDesiredSprintHeadBobShake() const{ return nullptr; }
UCameraAnimationSequence* AFGCharacterPlayer::GetDesiredWalkHeadBobShake() const{ return nullptr; }
UFGCharacterMovementComponent* AFGCharacterPlayer::GetFGMovementComponent() const{ return nullptr; }
AFGPlayerController* AFGCharacterPlayer::GetFGPlayerController() const{ return nullptr; }
void AFGCharacterPlayer::OnInteractWidgetAddedOrRemoved( UFGInteractWidget* widget, bool added){ }
void AFGCharacterPlayer::SetWantSprintBobbing(const bool wantBobbing){ }
FVector AFGCharacterPlayer::GetInventoryDropLocation() const{ return FVector(); }
void AFGCharacterPlayer::AddRadiationImmunity(const float toAdd){ }
void AFGCharacterPlayer::SetRadiationImmunity(const float newImmunity){ }
void AFGCharacterPlayer::ClientCheatWalk_Implementation(){ }
void AFGCharacterPlayer::Server_CheatWalk_Implementation(){ }
void AFGCharacterPlayer::ClientCheatFly_Implementation(){ }
void AFGCharacterPlayer::Server_CheatFly_Implementation(){ }
void AFGCharacterPlayer::CheatSetGhostFly(bool ghostModeActive){ }
void AFGCharacterPlayer::Server_CheatSetGhostFly_Implementation(bool ghostModeActive){ }
bool AFGCharacterPlayer::CheatToggleGhostFlyIsActive(){ return bool(); }
bool AFGCharacterPlayer::CheatToggleFlyModeIsActive(){ return bool(); }
void AFGCharacterPlayer::Server_CheatTeleport_Implementation(FTransform newTransform){ }
void AFGCharacterPlayer::CheatTeleport(){ }
void AFGCharacterPlayer::OnSlideStart(){ }
void AFGCharacterPlayer::OnSlideEnd(){ }
void AFGCharacterPlayer::Multicast_PlayJumpEffects_Implementation(bool boostJump){ }
void AFGCharacterPlayer::Client_HyperTubeStart_Implementation(UFGPipeConnectionComponentBase* connectionEnteredThrough, float startTime, float pipeVelocity, float pipeProgress, float pipeAccumulatedTime){ }
bool AFGCharacterPlayer::Client_HyperTubeStart_Validate(UFGPipeConnectionComponentBase* connectionEnteredThrough, float startTime, float pipeVelocity, float pipeProgress, float pipeAccumulatedTime){ return bool(); }
void AFGCharacterPlayer::Client_HyperTubeEnd_Implementation(FVector point, FVector velocity, float startTime){ }
bool AFGCharacterPlayer::Client_HyperTubeEnd_Validate(FVector point, FVector velocity, float startTime){ return bool(); }
void AFGCharacterPlayer::ZiplineStart(AActor* ziplineActor, const FVector& point1, const FVector& point2, const FVector& actorForward){ }
void AFGCharacterPlayer::ZiplineEnd(const FVector &exitForce) const{ }
void AFGCharacterPlayer::Multicast_ZiplineStart_Implementation(AActor* ziplineActor, const FVector& point1, const FVector& point2, const FVector& actorForward){ }
bool AFGCharacterPlayer::Multicast_ZiplineStart_Validate(AActor* ziplineActor, const FVector& point1, const FVector& point2, const FVector& actorForward){ return bool(); }
void AFGCharacterPlayer::Multicast_ZiplineEnd_Implementation(FVector exitForce){ }
bool AFGCharacterPlayer::Multicast_ZiplineEnd_Validate(FVector exitForce){ return bool(); }
void AFGCharacterPlayer::PlayZiplineEffects(const FVector &inLocation) const{ }
void AFGCharacterPlayer::PlayEmote(TSubclassOf<class UFGEmote> emote){ }
void AFGCharacterPlayer::Server_PlayEmote_Implementation(TSubclassOf<class UFGEmote> emote, int32 randomInteger){ }
void AFGCharacterPlayer::Multicast_PlayEmote_Implementation(TSubclassOf<class UFGEmote> emote, int32 randomInteger){ }
void AFGCharacterPlayer::PlayEmoteSFX( UAkAudioEvent* event){ }
void AFGCharacterPlayer::ClearEmoteSkelMeshComp(const float delay){ }
void AFGCharacterPlayer::Server_ToggleLightsInRadius_Implementation(float inRadius, float inDelay){ }
FFGPendingHyperJunctionInfo AFGCharacterPlayer::GetPendingHyperJunctionInfo() const{ return FFGPendingHyperJunctionInfo(); }
float AFGCharacterPlayer::GetTotalHyperTubeTravelDistance() const{ return float(); }
void AFGCharacterPlayer::Server_UpdateHyperJunctionOutputConnection_Implementation(UFGPipeConnectionComponentBase* connectionEnteredThrough, UFGPipeConnectionComponentBase* newOutputConnection){ }
bool AFGCharacterPlayer::Server_UpdateHyperJunctionOutputConnection_Validate(UFGPipeConnectionComponentBase* connectionEnteredThrough, UFGPipeConnectionComponentBase* newOutputConnection){ return bool(); }
UFGPipeConnectionComponentBase* AFGCharacterPlayer::GetHyperTubeJunctionOutputConnectionFromHistory(UFGPipeConnectionComponentBase* connectionEnteredThrough) const{ return nullptr; }
void AFGCharacterPlayer::SetIsFlyingToggleable(const bool canFlyingBeToggled){ }
void AFGCharacterPlayer::OnPhotoModeToggled(bool enabled){ }
int32 AFGCharacterPlayer::GetMappingContextPriority() const{ return int32(); }
void AFGCharacterPlayer::SetMappingContextEnabled(EPlayerMappingContextCategory contextMask, bool enabled){ }
void AFGCharacterPlayer::ClipboardCopy(){ }
void AFGCharacterPlayer::ClipboardPaste(){ }
void AFGCharacterPlayer::Input_Jump(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_Use(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_CloseBuildGunMenu(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleBuildGunBuild(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleBuildGunDismantle(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleBuildGunPaint(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_MoveAxis(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_LookAxis(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_TurnAxis(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_Sprint(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_Crouch(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_CycleEquipmentAxis(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_Holster(const FInputActionValue& ActionValue){ }
void AFGCharacterPlayer::Input_EmoteWheel(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_SampleBuilding(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleInventory(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleCodex(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleQuickSearch(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleFlashlight(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_ToggleFly(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Cheat_ToggleFly(){ }
void AFGCharacterPlayer::Input_ToggleGhostFly(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::Input_Teleport(const FInputActionValue& actionValue){ }
void AFGCharacterPlayer::SetMappingContextBound(UInputMappingContext* context, bool bind, int32 priority){ }
void AFGCharacterPlayer::RevivePlayerWithFullHealth(){ }
void AFGCharacterPlayer::SetPlayerFlyingOnSpawn(){ }
float AFGCharacterPlayer::GetUseDistance(){ return float(); }
bool AFGCharacterPlayer::GetIsInGasCloud() const{ return bool(); }
void AFGCharacterPlayer::SetIsInGasCloud(const bool isInGas){ }
void AFGCharacterPlayer::SetupPlayerInputComponent( UInputComponent* inputComponent){ }
void AFGCharacterPlayer::DestroyPlayerInputComponent(){ }
void AFGCharacterPlayer::BindActions(EActionsToBind actionsToBindMask){ }
void AFGCharacterPlayer::UnbindActions(){ }
void AFGCharacterPlayer::Native_OnLocallyPossessedChanged(bool isPossessed){ }
void AFGCharacterPlayer::OnInventorySlotsUnlocked(int32 newUnlockedSlots){ }
void AFGCharacterPlayer::OnArmsSlotsUnlocked(int32 newUnlockedSlots){ }
void AFGCharacterPlayer::CheckAndAddPositionToSafeList(FVector currentPos){ }
void AFGCharacterPlayer::CheckForWaterVolumeOverlaps(){ }
float AFGCharacterPlayer::AdjustDamage(AActor* damagedActor, float damageAmount, const  UDamageType* damageType,  AController* instigatedBy, AActor* damageCauser){ return float(); }
void AFGCharacterPlayer::DoRagdoll_Internal(){ }
void AFGCharacterPlayer::SetMeshVisibility(const bool isFirstPerson){ }
UAkAudioEvent* AFGCharacterPlayer::GetFootstepEvent(int32 footDown) const{ return nullptr; }
void AFGCharacterPlayer::OnDisabledInputGateChanged_Implementation(const FDisabledInputGate newValue){ }
void AFGCharacterPlayer::SetupInventory(){ }
void AFGCharacterPlayer::OnItemAddedToInventory(const TSubclassOf<UFGItemDescriptor> itemClass, int32 numAdded){ }
void AFGCharacterPlayer::OnInventorySlotUpdated(const int32 Index){ }
void AFGCharacterPlayer::AddDefaultInventoryItems(){ }
void AFGCharacterPlayer::ReEquipExistingEquipment(){ }
void AFGCharacterPlayer::UnEquipAllEquipment(){ }
void AFGCharacterPlayer::UpdateBestUsableActor(){ }
void AFGCharacterPlayer::OnUse(){ }
void AFGCharacterPlayer::OnUseStop(){ }
bool AFGCharacterPlayer::CanBePickedUp(const FHitResult& hitResult) const{ return bool(); }
void AFGCharacterPlayer::TurnAtRate(float Rate){ }
void AFGCharacterPlayer::LookUpAtRate(float Rate){ }
void AFGCharacterPlayer::SetBestUsableActor( AActor* newBestUsableActor){ }
void AFGCharacterPlayer::OnReviveTimerComplete(){ }
float AFGCharacterPlayer::GetReviveProgress() const{ return float(); }
void AFGCharacterPlayer::Client_Revived_Implementation(){ }
void AFGCharacterPlayer::Client_ReviveStarted_Implementation(){ }
void AFGCharacterPlayer::Client_ReviveEnded_Implementation(){ }
float AFGCharacterPlayer::GetPickupProgress() const{ return float(); }
void AFGCharacterPlayer::StartReceivingRadiation(){ }
void AFGCharacterPlayer::StopReceivingRadiation(){ }
void AFGCharacterPlayer::TornOff(){ }
void AFGCharacterPlayer::DebugBuildablesInFrustum() const{ }
void AFGCharacterPlayer::TriggerBestUsableActorDelegate(){ }
void AFGCharacterPlayer::UpdateHUDCrosshair(){ }
bool AFGCharacterPlayer::IsSliding() const{ return bool(); }
bool AFGCharacterPlayer::IsInPumpiMode() const{ return bool(); }
void AFGCharacterPlayer::UpdatePlayerNameWidget(){ }
void AFGCharacterPlayer::UpdatePlayerStatus(){ }
AFGPlayerState* AFGCharacterPlayer::GetControllingPlayerState() const{ return nullptr; }
AFGEquipment* AFGCharacterPlayer::SpawnEquipment(const TSubclassOf< AFGEquipment > &equipmentClass, AActor* owner) const{ return nullptr; }
AFGEquipmentAttachment* AFGCharacterPlayer::SpawnAttachmentForEquipment(const AFGEquipment* equipment){ return nullptr; }
AFGEquipmentAttachment* AFGCharacterPlayer::SpawnSecondaryAttachmentForEquipment(const AFGEquipment* equipment){ return nullptr; }
bool AFGCharacterPlayer::UpdateActorPerceptionInfo(FFGActorPlayerPerceptionInfo& info) const{ return bool(); }
void AFGCharacterPlayer::RemoveActorPerceptionInfo(const FFGActorPlayerPerceptionInfo& info){ }
void AFGCharacterPlayer::UpdateHeadBob(){ }
void AFGCharacterPlayer::NotifyGameStatePlayerAdded(){ }
void AFGCharacterPlayer::UpdateGameUIRadiationStatus(){ }
void AFGCharacterPlayer::UpdateGameUIRadiationIntensity() const{ }
int32 AFGCharacterPlayer::GetTotalPlayerInventorySlots() const{ return int32(); }
int32 AFGCharacterPlayer::GetTotalPlayerArmEquipmentSlots() const{ return int32(); }
void AFGCharacterPlayer::Server_EquipEquipment_Implementation(AFGEquipment* newEquipment){ }
bool AFGCharacterPlayer::Server_EquipEquipment_Validate(AFGEquipment* newEquipment){ return bool(); }
void AFGCharacterPlayer::Server_UnequipEquipment_Implementation(AFGEquipment* newEquipment){ }
bool AFGCharacterPlayer::Server_UnequipEquipment_Validate(AFGEquipment* newEquipment){ return bool(); }
void AFGCharacterPlayer::Server_ToggleEquipment_Implementation(){ }
void AFGCharacterPlayer::Server_RevivePlayer_Implementation(AFGCharacterPlayer* playerToRevive){ }
void AFGCharacterPlayer::Server_OnUse_Implementation(){ }
bool AFGCharacterPlayer::Server_OnUse_Validate(){ return bool(); }
void AFGCharacterPlayer::Server_OnUseReleased_Implementation(){ }
bool AFGCharacterPlayer::Server_OnUseReleased_Validate(){ return bool(); }
void AFGCharacterPlayer::Server_PickUpItem_Implementation( AFGItemPickup* itemPickup){ }
bool AFGCharacterPlayer::Server_PickUpItem_Validate( AFGItemPickup* itemPickup){ return bool(); }
void AFGCharacterPlayer::Server_PickUpBoomBoxPlayer_Implementation( AFGBoomBoxPlayer* boomBox){ }
void AFGCharacterPlayer::Client_OnPerceivingCreatureStateChange_Implementation(AFGCreature* creature, ECreatureState newState){ }
void AFGCharacterPlayer::OnPerceivingCreatureStateChange_Internal(AFGCreature* creature, ECreatureState newState) const{ }
void AFGCharacterPlayer::OnSlideStatusUpdated(){ }
void AFGCharacterPlayer::MakeSlidingNoise(){ }
void AFGCharacterPlayer::OnRep_ActiveEquipments(){ }
void AFGCharacterPlayer::OnRep_ActiveAttachments(){ }
void AFGCharacterPlayer::OnRep_DrivenVehicle(){ }
void AFGCharacterPlayer::OnRep_PickupCounter(){ }
void AFGCharacterPlayer::OnRep_InRadioactiveZone(){ }
void AFGCharacterPlayer::OnRep_RadiationIntensity(){ }
void AFGCharacterPlayer::OnRep_IsSliding(){ }
void AFGCharacterPlayer::OnRep_ArmsEquipmentSlot(){ }
void AFGCharacterPlayer::OnRep_BackEquipmentSlot(){ }
void AFGCharacterPlayer::OnRep_LegsEquipmentSlot(){ }
void AFGCharacterPlayer::OnRep_HeadEquipmentSlot(){ }
void AFGCharacterPlayer::OnRep_BodyEquipmentSlot(){ }
void AFGCharacterPlayer::OnRep_PlayerInventory(){ }
void AFGCharacterPlayer::OnRep_PendingHyperJunctionOutputConnection(){ }
void AFGCharacterPlayer::OnRep_ActorPerceptionInfo(const TArray< FFGActorPlayerPerceptionInfo >& OldValues){ }
void AFGCharacterPlayer::MigrateNumSavedSlots(){ }
void AFGCharacterPlayer::CheckItemPickedUp() const{ }
void AFGCharacterPlayer::OnRep_IsPossessed(){ }
void AFGCharacterPlayer::OnRep_PlayerState(){ }
void AFGCharacterPlayer::SetOnlineState(const bool isPlayerOnline){ }
void AFGCharacterPlayer::UpdateFlyingIsToggleable(){ }
bool AFGCharacterPlayer::HasHolsteredEquipment() const{ return bool(); }
int32 AFGCharacterPlayer::GetHolsteredEquipmentIndex() const{ return int32(); }
bool AFGCharacterPlayer::FilterInventoryClasses(TSubclassOf< UObject > object, int32 idx) const{ return bool(); }
void AFGCharacterPlayer::InitializePreferredCameraMode(){ }
void AFGCharacterPlayer::DoUnSlide(){ }
void AFGCharacterPlayer::OnUserSettingsUpdated(){ }
void AFGCharacterPlayer::OnActiveEquipmentChangedInSlot(EEquipmentSlot slot){ }
FOnPersistentEquipmentSpawned AFGCharacterPlayer::OnPersistentEquipmentSpawned = FOnPersistentEquipmentSpawned();
FOnEquipmentEquipped AFGCharacterPlayer::OnEquipmentEquipped = FOnEquipmentEquipped();
FOnEquipmentUnequipped AFGCharacterPlayer::OnEquipmentUnequipped = FOnEquipmentUnequipped();
FOnFoliagePickupSpawned AFGCharacterPlayer::OnFoliagePickupSpawned = FOnFoliagePickupSpawned();
FOnPlayerInputInitializedDelegate AFGCharacterPlayer::OnPlayerInputInitialized = FOnPlayerInputInitializedDelegate();
FSimpleCharacterPlayerDelegate AFGCharacterPlayer::OnPlayerInputDestroyed = FSimpleCharacterPlayerDelegate();
FSimpleCharacterPlayerDelegate AFGCharacterPlayer::OnPlayerCreated = FSimpleCharacterPlayerDelegate();
FSimpleCharacterPlayerDelegate AFGCharacterPlayer::OnPlayerBegunPlay = FSimpleCharacterPlayerDelegate();
