// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGDroneVehicle.h"
#include "Net/UnrealNetwork.h"

AFGDroneVehicle::AFGDroneVehicle() : Super() {
	this->mStorageInventory = nullptr;
	this->mBatteryInventory = nullptr;
	this->mInventorySize = 20;
	this->mBatteryStorageSize = 1;
	this->mDockingSequenceDuration = 0.0;
	this->mTakeoffSequenceDuration = 0.0;
	this->mTravelStartSequenceDuration = 0.0;
	this->mFlyingSpeed = 0.0;
	this->mTravelingSpeed = 0.0;
	this->mFlyingStoppingDistance = 0.0;
	this->mTravelingStoppingDistance = 0.0;
	this->mTurningStrength = 0.0;
	this->mCurrentPowerLevel = 0.0;
	this->mCurrentTripPowerCost = 0.0;
	this->mCurrentTripInformation.TripDuration = 0.0;
	this->mCurrentTripInformation.IncomingItemStacks = 0.0;
	this->mCurrentTripInformation.OutgoingItemStacks = 0.0;
	this->mHasBegunTrip = false;
	this->mIsBraking = false;
	this->mCurrentVelocity = FVector::ZeroVector;
	this->mCurrentDestination = FVector::ZeroVector;
	this->mDesiredFacingDirection = FVector::ZeroVector;
	this->mCurrentFlyingMode = EDroneFlyingMode::DFM_None;
	this->mCurrentDockingState.State = EDroneDockingState::DS_UNDOCKED;
	this->mCurrentDockingState.StateStartTime = 0.0;
	this->mStopAtDestination = false;
	this->mDockedStation = nullptr;
	this->mHomeStation = nullptr;
	this->mCurrentDestinationStation = nullptr;
	this->mCurrentAction = nullptr;
}
void AFGDroneVehicle::Serialize(FArchive& Ar){ Super::Serialize(Ar); }
void AFGDroneVehicle::BeginPlay(){ }
void AFGDroneVehicle::Tick(float DeltaTime){ }
void AFGDroneVehicle::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const {
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
	DOREPLIFETIME(AFGDroneVehicle, mIsBraking);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentVelocity);
	DOREPLIFETIME(AFGDroneVehicle, mDesiredFacingDirection);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentFlyingMode);
	DOREPLIFETIME(AFGDroneVehicle, mCurrentDockingState);
	DOREPLIFETIME(AFGDroneVehicle, mDockedStation);
}
void AFGDroneVehicle::EndPlay(const EEndPlayReason::Type EndPlayReason){ }
bool AFGDroneVehicle::IsUseable_Implementation() const{ return bool(); }
void AFGDroneVehicle::Dismantle_Implementation(){ }
void AFGDroneVehicle::OnIsSimulatedChanged(){ }
void AFGDroneVehicle::GainedSignificance_Implementation(){ }
void AFGDroneVehicle::LostSignificance_Implementation(){ }
void AFGDroneVehicle::PostLoadGame_Implementation(int32 saveVersion, int32 gameVersion){ }
bool AFGDroneVehicle::AddAsRepresentation(){ return bool(); }
bool AFGDroneVehicle::UpdateRepresentation(){ return bool(); }
bool AFGDroneVehicle::RemoveAsRepresentation(){ return bool(); }
bool AFGDroneVehicle::IsActorStatic(){ return bool(); }
FVector AFGDroneVehicle::GetRealActorLocation(){ return FVector(); }
FRotator AFGDroneVehicle::GetRealActorRotation(){ return FRotator(); }
UTexture2D* AFGDroneVehicle::GetActorRepresentationTexture(){ return nullptr; }
FText AFGDroneVehicle::GetActorRepresentationText(){ return FText(); }
void AFGDroneVehicle::SetActorRepresentationText(const FText& newText){ }
FLinearColor AFGDroneVehicle::GetActorRepresentationColor(){ return FLinearColor(); }
void AFGDroneVehicle::SetActorRepresentationColor(FLinearColor newColor){ }
ERepresentationType AFGDroneVehicle::GetActorRepresentationType(){ return ERepresentationType(); }
bool AFGDroneVehicle::GetActorShouldShowInCompass(){ return bool(); }
bool AFGDroneVehicle::GetActorShouldShowOnMap(){ return bool(); }
EFogOfWarRevealType AFGDroneVehicle::GetActorFogOfWarRevealType(){ return EFogOfWarRevealType(); }
float AFGDroneVehicle::GetActorFogOfWarRevealRadius(){ return float(); }
ECompassViewDistance AFGDroneVehicle::GetActorCompassViewDistance(){ return ECompassViewDistance(); }
void AFGDroneVehicle::SetActorCompassViewDistance(ECompassViewDistance compassViewDistance){ }
void AFGDroneVehicle::NotifyPairedStationUpdated( AFGBuildableDroneStation* NewPairedStation){ }
void AFGDroneVehicle::OnUndocked(){ }
void AFGDroneVehicle::OnDockedStationDestroyed(){ }
void AFGDroneVehicle::OnBeginLoadVehicle_Implementation(){ }
void AFGDroneVehicle::OnBeginUnloadVehicle_Implementation(){ }
void AFGDroneVehicle::OnTransferComplete_Implementation(){ }
TArray<FVector> AFGDroneVehicle::GeneratePathToDestination(const FVector& CurrentLocation, const FVector& Destination, UWorld* World){ return TArray<FVector>(); }
void AFGDroneVehicle::SetCurrentDestination(const FVector& NewDestination, EDroneFlyingMode FlyingMode, bool StopAtDestination){ }
void AFGDroneVehicle::StopMoving(){ }
void AFGDroneVehicle::BeginDocking( AFGBuildableDroneStation* station){ }
void AFGDroneVehicle::UpdateDockingQueuePosition(int NewPosition){ }
float AFGDroneVehicle::GetSpeedForFlyingMode(EDroneFlyingMode Mode) const{ return float(); }
float AFGDroneVehicle::GetStoppingDistanceForFlyingMode(EDroneFlyingMode Mode) const{ return float(); }
float AFGDroneVehicle::GetTimeSinceDockingStateChanged() const{ return float(); }
void AFGDroneVehicle::SetHomeStation( AFGBuildableDroneStation* station){ }
bool AFGDroneVehicle::GrabRequiredBatteriesForTrip( AFGBuildableDroneStation* FromStation,  AFGBuildableDroneStation* ToStation, bool AllowTravelWithoutCost){ return bool(); }
bool AFGDroneVehicle::TravelToStation( AFGBuildableDroneStation* station, bool ShouldTransferItems){ return bool(); }
void AFGDroneVehicle::BeginNewTrip( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndCurrentTrip(bool Completed){ }
void AFGDroneVehicle::SetFacingDirection(const FVector& Direction){ }
void AFGDroneVehicle::StartDockingSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndDockingSequence_Implementation( AFGBuildableDroneStation* Station, bool ShouldTransferItems){ }
void AFGDroneVehicle::StartTakeoffSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::EndTakeoffSequence_Implementation( AFGBuildableDroneStation* Station){ }
void AFGDroneVehicle::StartTravelStartSequence_Implementation(){ }
void AFGDroneVehicle::EndTravelStartSequence_Implementation(){ }
void AFGDroneVehicle::OnRep_IsBraking(){ }
void AFGDroneVehicle::OnRep_FlyingMode(){ }
void AFGDroneVehicle::OnRep_DockingState(){ }
void AFGDroneVehicle::OnRep_DockedStation(){ }
void AFGDroneVehicle::OnSignificanceUpdate(){ }
void AFGDroneVehicle::ClearAllActions(bool KeepCurrentAction){ }
void AFGDroneVehicle::SetNewFlyingMode(EDroneFlyingMode Mode){ }
void AFGDroneVehicle::SetDockingState(EDroneDockingState State){ }
bool AFGDroneVehicle::ConsumeBatteriesForPower(float PowerRequirement){ return bool(); }
void AFGDroneVehicle::CalculateInventoryPotentialPower(){ }
FDroneAction* AFGDroneVehicle::MigrateLegacyAction( UFGDroneAction* action){ return nullptr; }
FGDroneActionFactory::FGDroneActionFactory(AFGDroneVehicle* drone){ }
#ifdef DEBUG_DRONES
void FDroneAction::DisplayDebugInformation(){ }
#endif 
FDroneAction::FDroneAction(){ }
FDroneAction::FDroneAction(AFGDroneVehicle* drone){ }
UScriptStruct* FDroneAction::GetActionStaticStruct() const{ return nullptr; }
void FDroneAction::PushAction(FDroneAction* action){ }
#ifdef DEBUG_DRONES
void FDroneAction_Timed::DisplayDebugInformation(){ }
#endif 
FDroneAction_Timed::FDroneAction_Timed(){ }
FDroneAction_Timed::FDroneAction_Timed(AFGDroneVehicle* drone){ }
void FDroneAction_Timed::Tick(float dt){ }
bool FDroneAction_Timed::IsDone() const{ return bool(); }
#ifdef DEBUG_DRONES
void FDroneAction_TraversePath::DisplayDebugInformation(){ }
#endif 
FDroneAction_TraversePath::FDroneAction_TraversePath(){ }
FDroneAction_TraversePath::FDroneAction_TraversePath(AFGDroneVehicle* drone, const TArray< FVector >& path, EDroneFlyingMode flyingMode, bool stopAtDestination){ }
FDroneAction_TraversePath::FDroneAction_TraversePath(AFGDroneVehicle* drone, const UFGDroneAction_TraversePath* legacyAction){ }
void FDroneAction_TraversePath::Begin(){ }
void FDroneAction_TraversePath::Tick(float dt){ }
void FDroneAction_TraversePath::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
bool FDroneAction_TraversePath::IsDone() const{ return bool(); }
void FDroneAction_TraversePath::GotoNextDestination(){ }
#ifdef DEBUG_DRONES
void FDroneAction_RequestDocking::DisplayDebugInformation(){ }
#endif 
FDroneAction_RequestDocking::FDroneAction_RequestDocking(){ }
FDroneAction_RequestDocking::FDroneAction_RequestDocking(AFGDroneVehicle* drone,  AFGBuildableDroneStation* station, bool shouldTransferItems){ }
FDroneAction_RequestDocking::FDroneAction_RequestDocking(AFGDroneVehicle* drone, const UFGDroneAction_RequestDocking* legacyAction){ }
void FDroneAction_RequestDocking::Begin(){ }
void FDroneAction_RequestDocking::End(){ }
void FDroneAction_RequestDocking::MoveToDesignatedQueuePosition(EDroneFlyingMode FlyingMode){ }
void FDroneAction_RequestDocking::Tick(float dt){ }
void FDroneAction_RequestDocking::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
bool FDroneAction_RequestDocking::IsDone() const{ return bool(); }
FDroneAction_DockingSequence::FDroneAction_DockingSequence(){ }
FDroneAction_DockingSequence::FDroneAction_DockingSequence(AFGDroneVehicle* drone,  AFGBuildableDroneStation* station, bool shouldTransferItems){ }
FDroneAction_DockingSequence::FDroneAction_DockingSequence(AFGDroneVehicle* drone, const UFGDroneAction_DockingSequence* legacyAction){ }
void FDroneAction_DockingSequence::Begin(){ }
void FDroneAction_DockingSequence::End(){ }
float FDroneAction_DockingSequence::GetActionDuration() const{ return float(); }
FDroneAction_TakeoffSequence::FDroneAction_TakeoffSequence(){ }
FDroneAction_TakeoffSequence::FDroneAction_TakeoffSequence(AFGDroneVehicle* drone,  AFGBuildableDroneStation* station){ }
FDroneAction_TakeoffSequence::FDroneAction_TakeoffSequence(AFGDroneVehicle* drone, const UFGDroneAction_TakeoffSequence* legacyAction){ }
void FDroneAction_TakeoffSequence::Begin(){ }
void FDroneAction_TakeoffSequence::End(){ }
float FDroneAction_TakeoffSequence::GetActionDuration() const{ return float(); }
void FDroneAction_TakeoffSequence::ReceiveActionEvent(EDroneActionEvent ActionEvent, void* EventData){ }
FDroneAction_TravelStartSequence::FDroneAction_TravelStartSequence(){ }
FDroneAction_TravelStartSequence::FDroneAction_TravelStartSequence(AFGDroneVehicle* drone, const FVector& destination){ }
FDroneAction_TravelStartSequence::FDroneAction_TravelStartSequence(AFGDroneVehicle* drone, const UFGDroneAction_TravelStartSequence* legacyAction){ }
void FDroneAction_TravelStartSequence::Begin(){ }
void FDroneAction_TravelStartSequence::End(){ }
float FDroneAction_TravelStartSequence::GetActionDuration() const{ return float(); }
